import pandas as pd
kdrama_info = {'Ojingeo geim': {'name': 'Игра в кальмара', 'genre': 'триллер, драма', 'age restrictions': 18, 'year': 2021, 'actors': ['Ли Джон-джэ', 'Пак Хэ-су', 'О Ён-су', 'Чон Хо-ён', 'Хо Сон-тхэ', 'Анупам Трипати', 'Ким Джу-рён', 'Ви Ха-джун', 'Ю Сон-джу', 'Ли Ю-ми'], 'rating': 7.5, 'review': 'Сон Ги-хун уже немолод, разведён, по уши погряз в долгах и сидит на шее у старенькой матери. Даже выигранные на скачках деньги в его руках долго не задерживаются, и однажды он встречает в метро загадочного незнакомца, который сначала предлагает сыграть в детскую игру, а затем вручает Ги-хуну немалую сумму и визитку. Но радость мужчины сменятся отчаянием, когда он узнаёт, что бывшая жена с новым мужем собираются увезти его дочь в Америку. Он звонит по номеру с визитки и становится последним участником тайных игр на выживание с призом в 40 миллионов долларов. Среди товарищей по несчастью оказываются его друг детства — прогоревший финансист, бандит, смертельно больной старик, северокорейская перебежчица, иммигрант из Пакистана и многие другие отчаянно нуждающиеся в деньгах.'},
               'Dokkaebi': {'name': 'Демон', 'genre': 'фэнтези, мелодрама, драма, комедия', 'age restrictions': 16, 'year': 2016, 'actors': ['Кон Ю', 'Ким Го-ын', 'Ли Дон-ук', 'Ю Ин-на', 'Юк Сон-джэ', 'Ли Эль', 'Чо У-джин', 'Ким Сон-гём', 'Пак Хи-бон', 'Хан Со-джин'], 'rating': 8.6, 'review': 'Бессмертный демон токкэби много лет живет среди смертных и порядком устал от жизни. Но если ты волшебное существо, есть лишь один способ поставить точку и покинуть бренный мир — жениться на смертной. Избранницей демона становится девушка, которая может видеть призраков. А ангел смерти, чья задача провожать души умерших в загробный мир, тем временем потерял память.'},
               'W': {'name': 'Параллельные миры', 'genre': 'мелодрама, фэнтези, триллер', 'age restrictions': 16, 'year': 2016, 'actors': ['Ли Джон-сок', 'Хан Хё-джу', 'Чон Ю-джин', 'Кан Ги-ён', 'Ким И-сон', 'Ли Щи-он', 'Ли Тхэ-хван', 'Пак Вон-сан', 'Хо Джон-до', 'Хван Сок-чон'], 'rating': 8.1, 'review': 'История о странном и загадочном романе между парнем Кан-чхолем, который очень богат, но существует только в вэб-комиксе «W», и девушкой О Ён-джу, которая является хирургом в реальном мире.'},
               'Yeosingangrim': {'name': 'Истинная красота', 'genre': 'мелодрама, комедия', 'age restrictions': 16, 'year': 2020, 'actors': ['Мун Га-ён', 'Чха Ын-у', 'Хван Ин-ёп', 'Пак Ю-на', 'Лим Сэ-ми', 'Пак Хо-сан', 'О И-щик', 'Кан Мин-а', 'Щин Джэ-хви', 'Чон Хе-вон'], 'rating': 8.2, 'review': 'Старшеклассница Лим Джу-гён с комплексом по поводу своей внешности привыкла краситься и достигла в этом деле определённого мастерства. Она начинает встречаться с двумя самыми видными парнями.'}}


def get_info(kdrama_info, *args, info='review, korean name'):
    index = []  # список введенных пользователем годов
    names = []  # список имен
    years = []  # список годов для каждого фильма
    inf = info.split(", ")  # разбиваем введенный запрос на отдельные части
    setting = []  # здесь будут храниться словари, в которых лежат кастомные запросы
    for i in args:  # считываем все года введенные пользователем
        index.append(i)
    for k, v in kdrama_info.items():  # далее начинаем проходить по исходному словарю
        year = v.get('year')  # запоминаем год фильма

        if len(index) == 1:  # далее основной код одинаковый, только три блока условия по годам
            if year >= index[0]:  # если год больше чем введенный
                names.append(v.get('name'))  # добавляем в список название
                years.append(year)  # добавляем в список год
                dict = {}  # формируем словарь
                for i in inf:  # проходимся по кастомным запросам
                    if i == 'korean name':  # если там есть вот это вот, то нужно передать клбч словаря, т.е. название фильма
                        dict['korean name'] = k  # добавляем название в словарь
                    elif i == 'name' or i == 'year':  # пропускаем поля name и year если они введены пользователем
                        pass
                    else:  # для остальных запросов просто запоминаем значения и вносим их в словарь
                        dict[i] = v.get(i)
                setting.append(dict)  # добавляем словарь в список

        elif len(index) == 2:  # здесь цикл если введены два года
            # если г.в находится в промежутке
            if (year <= index[1] and year >= index[0]) or (year >= index[1] and year <= index[0]):
                names.append(v.get('name'))
                years.append(year)
                dict = {}
                for i in inf:
                    if i == 'korean name':
                        dict['korean name'] = k
                    elif i == 'name' or i == 'year':
                        pass
                    else:
                        dict[i] = v.get(i)
                setting.append(dict)

        else:
            if year in index:  # если введено более 2х
                names.append(v.get('name'))
                years.append(year)
                dict = {}
                for i in inf:
                    if i == 'korean name':
                        dict['korean name'] = k
                    elif i == 'name' or i == 'year':
                        pass
                    else:
                        dict[i] = v.get(i)
                setting.append(dict)

    data = {'year': years, 'name': names}  # формируем датасет
    for i in setting:  # проходимся по списку словарей
        for k, v in i.items():  # значения из каждого словаря вносим в датасет
            data[k] = v
    df = pd.DataFrame(data=data)  # формируем датафрейм

    isshow = bool(df['name'].tolist())  # проверяем пустой он или нет
    if isshow:  # если не пустой
        df = df.sort_values(by='year')  # сортируем по годам
        df.reset_index(drop=True, inplace=True)  # сбрасываем индексы
        print(df)  # выводим датафрейм
    else:
        # ну или выводим это, если ничего нет
        print('По Вашему запросу ничего не найдено')


get_info(kdrama_info, 2016, info='genre, rating')
